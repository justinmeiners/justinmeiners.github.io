<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Literate programming is much more than commenting code</title>
<link rel="stylesheet" href="google-code-prettify/prettify.css">
<link rel="stylesheet" href="styles/prettify-theme.css">
<script defer src="google-code-prettify/prettify.js"></script>
<script defer src="google-code-prettify/run_prettify.js"></script>
<link rel="stylesheet" href="katex/katex.min.css">
<script defer src="katex/katex.min.js"></script>
<script>
    function addMath() {
        var macros = {};
        var blocks = document.querySelectorAll('.math-block');

        for (var element of blocks) {
            katex.render(element.textContent, element, {
                throwOnError: false,
                displayMode: true,
                macros: macros
            });
        }

        var inline = document.querySelectorAll('.math');

        for (var element of inline) {
            katex.render(element.textContent, element, {
                throwOnError: false,
                displayMode: false,
                macros: macros
            });
        }
    }
    </script>
<link rel="stylesheet" href="styles/main.css">
</head>
<body onload="addMath()">
<!-- Generated by srcweave https://github.com/justinmeiners/srcweave -->
<h1>Literate programming is much more than commenting code<a id="c0"></a></h1>


<p><strong>03/07/22</strong></p>

<p>Most programmers haven&rsquo;t heard of <a href="https://en.wikipedia.org/wiki/Literate_programming">literate programming</a>,
and the few that have tend to think it means writing a lot of comments around your code.
However, simply explaining code with prose, <em>does not</em> constitute literate programming.
Consider the following quote from it&rsquo;s inventor:</p>

<blockquote><p> Some of my major programs could not have been written with any other methodology that I&rsquo;ve ever heard of.
The complexity was simply too daunting for my limited brain to handle;
without literate programming, the whole enterprise would have flopped miserably.
&hellip; Literate programming is what you need to rise above the ordinary level of achievement &ndash; Donald Knuth</p></blockquote>

<p>Does this extraordinary leap in effectiveness sound like something that comes from re-explaining what code does?
I didn&rsquo;t think so.</p>

<p>The real advantages of literate programming come from two principles:</p>

<ol>
<li><p>Code should be written for humans not machines.</p></li>
<li><p>Program designers utilize many types of information, not just code.</p></li>
</ol>


<p>Literate programming systems help programmers apply these principles
by providing two standard operations <strong>tangle</strong> and <strong>weave</strong> which
 manipulate and organize source code.</p>

<h2>1. Tangle<a id="s0:0"></a></h2>


<p>Literate programs are written in plain text documents,
but between the traditional prose, blocks of code (in any language) are interleaved.
For example:</p>

<div class="code-block">
<span class="block-header">
<strong class="block-title"><em><a id="btest_subsets:34" href="#btest_subsets:34">test subsets</a></em></strong></span>
<pre class="prettyprint"><code class="">console.log( subsets([1, 2, 3, 4]) );
</code></pre>
<p class="block-usages"><small>Used by <a href="#bsubsets.js:77" title="index.lit:78 subsets.js">1</a> </small></p></div>


<p>You can think of them like markdown documents, but with an important addition.
In a literate program, blocks of code have <em>identifiers</em>, and they can <em>reference</em> each other.
Each reference modifies the contents of a prior block,
or includes it at the specificied location.</p>

<p>The operation <strong>tangle</strong> resolves all these references and produces normal source code to be read by the compiler.</p>

<h3>Example</h3>

<p>Let&rsquo;s try it out.
In the block above we introduced a <code>subsets</code> function, also know as the powerset:</p>

<div class="math-block">\begin{equation}   \mathcal{P}(A) = \{ S \text{ is a set } \colon S \subseteq A \}\end{equation}</div>


<p>Implementing it can be a little bit tricky.
If you have never done it before, I recommend you write out some examples
on paper and see if you can figure it out.</p>

<div class="math-block">\begin{align}    \mathcal{P}(\{1, 2, 3\}) = \{ &\{1, 2, 3\}, \\
                                  &\{1, 2\}, \{1, 3\}, \{2, 3\}, \\
                                  &\{1\}, \{2\}, \{3\}, \\
                                  &\emptyset \} \\\end{align}</div>


<p>The key insight, is that if we take an element out of the original set,
and all the subsets which contain it, we can get back
the full subsets, by making a copy of each other subset and inserting
the element back in.
In other words, the number of subsets <em>doubles</em> with each element in the set:</p>

<div class="math-block">\begin{equation}    |\mathcal{P}(A)| = 2^{|A|}\end{equation}</div>


<p>Here is rough outline in code:</p>

<div class="code-block">
<span class="block-header">
<strong class="block-title"><em><a id="bsubsets.js:77" href="#bsubsets.js:77">subsets.js</a></em></strong></span>
<pre class="prettyprint"><code class="">function subsets(set) {
    <em class="block-link nocode" title="index.lit:92"><a href="#bbase_case:91">@{base case}</a></em>
    <em class="block-link nocode" title="index.lit:98"><a href="#bremove_element_and_compute_subsets_of_smaller_set:97">@{remove element and compute subsets of smaller set}</a></em>
    return <em class="block-link nocode" title="index.lit:104"><a href="#bsubsets_without_element:103">@{subsets without element}</a></em>
        .concat( <em class="block-link nocode" title="index.lit:111"><a href="#bsubsets_with_element:110">@{subsets with element}</a></em> );
}

<em class="block-link nocode" title="index.lit:35"><a href="#btest_subsets:34">@{test subsets}</a></em>
</code></pre>
</div>


<p>This a recursive function, so we need a base case.
If the input set is empty, its only subset is the empty set:</p>

<div class="code-block">
<span class="block-header">
<strong class="block-title"><em><a id="bbase_case:91" href="#bbase_case:91">base case</a></em></strong></span>
<pre class="prettyprint"><code class="">if (set.length == 0) { return [[]]; }
</code></pre>
<p class="block-usages"><small>Used by <a href="#bsubsets.js:77" title="index.lit:78 subsets.js">1</a> </small></p></div>


<p>We use recursion by removing one element and computing the subsets of that array:</p>

<div class="code-block">
<span class="block-header">
<strong class="block-title"><em><a id="bremove_element_and_compute_subsets_of_smaller_set:97" href="#bremove_element_and_compute_subsets_of_smaller_set:97">remove element and compute subsets of smaller set</a></em></strong></span>
<pre class="prettyprint"><code class="">const element = set.pop();
const smaller = subsets(set);
</code></pre>
<p class="block-usages"><small>Used by <a href="#bsubsets.js:77" title="index.lit:78 subsets.js">1</a> </small></p></div>


<p>All the smaller subsets are still subsets of our original set, so we want to include those.</p>

<div class="code-block">
<span class="block-header">
<strong class="block-title"><em><a id="bsubsets_without_element:103" href="#bsubsets_without_element:103">subsets without element</a></em></strong></span>
<pre class="prettyprint"><code class="">smaller
</code></pre>
<p class="block-usages"><small>Used by <a href="#bsubsets.js:77" title="index.lit:78 subsets.js">1</a> </small></p></div>


<p>But, we are missing all the subsets involving <code>element</code>. We simply
add <code>element</code> in to each set.</p>

<div class="code-block">
<span class="block-header">
<strong class="block-title"><em><a id="bsubsets_with_element:110" href="#bsubsets_with_element:110">subsets with element</a></em></strong></span>
<pre class="prettyprint"><code class="">smaller.map(s =&gt; s.concat([element]))
</code></pre>
<p class="block-usages"><small>Used by <a href="#bsubsets.js:77" title="index.lit:78 subsets.js">1</a> </small></p></div>


<p>That&rsquo;s all!
Applying <strong>tangle</strong> to the <a href="index.lit">literate</a> file produces a single source file <a href="src/subsets.js">subsets.js</a>.</p>

<p>A typical literate file produces many source files.
Block types aren&rsquo;t limited to a single language either.
Here is how to run it in your command line:</p>

<div class="code-block">
<span class="block-header">
<strong class="block-title"><em><a id="btest_command:122" href="#btest_command:122">test command</a></em></strong></span>
<pre class="prettyprint"><code class="">node subsets.js
</code></pre>
</div>




<h2>2. Discussion<a id="s0:1"></a></h2>


<p>Of course, the example above goes into more detail than is helpful for most production code.
It is just meant to illustrate how dividing code into blocks can make them significantly more readable,
with logical explanation along the way, and a little bit of analysis.</p>

<p>At the micro-level we can overcome a lot of limitations imposed by the language syntax,
kind of like a powerful macro system.
In the example we break out small sub-expressions, even from the middle of statement,
to explain further, or to make things more readable.</p>

<p>Some other use cases include:</p>

<ul>
<li>Separating inline SQL queries from string literals.</li>
<li>Avoiding forward declarations in <code>C</code>.</li>
<li>Breaking up large switch cases.</li>
<li>Separating error handling from main logic.</li>
</ul>


<p>More importantly, at the macro level we can control the overall presentation of the program.
This is difficult to convey in a brief article,
but think of it like writing code as a book or article.
You can introduce your code with an overview,
take time to develop the most important ideas and characters,
gradually build up to the big picture,
and then maybe fill in some extra details.</p>

<p>Consider the last time you started working on a large code base someone else wrote.
It was probably overwhelming, especially considering how much of modern code is boiler plate, and interfacing between systems.
Even with a well-written README, you probably wanted to know:</p>

<ul>
<li>What code most important and what should be read first?</li>
<li>What are they key data structures and algorithms?</li>
<li>How is data stored?</li>
<li>Which files are boiler plate that I can ignore?</li>
</ul>


<p>Literate programs allow you to answer these questions naturally.
Once again, it&rsquo;s difficult to convey.
See the end for sample example programs you can read.</p>

<h2>3. Weave<a id="s0:2"></a></h2>


<p>The <strong>weave</strong> operation generates documentation files from the literate file.
This is a nicely formatted document like the one you are reading right now!
This presents the code in a readable form,</p>

<p>If you are like me, you probably maintain some kind of design document recording decisions make
during the project and data to provide justifications.
Not, all of this content is appropriate to include in the source code, but a lot of it is,
and the literate <strong>weave</strong> operation let&rsquo;s you do just that.</p>

<p>Here are some examples of media you can include, as well as a specific use case I have desired in the past:</p>

<ul>
<li>Diagrams and images (instead of the ASCII kind). Illustrate a suite of test cases.</li>
<li>Graphs and plots. Illustrate what a function looks like.</li>
<li>Math formulas and equations. Analyze an algorithm.</li>
<li>Tables of data. Record survey data that justifies a decision made in code.</li>
<li>Screenshots. Show the bug this section of code fixes.</li>
<li>Example inputs and outputs. Show how to use a pieces of code.</li>
</ul>


<p>It&rsquo;s important to note how this is different from tools which generate interface &ldquo;documentation&rdquo; from source code.
Literate programs usually include the <em>entire</em> source, not just interfaces.
Since it focuses on prose, it&rsquo;s much more natural to include other media formats.
You aren&rsquo;t littering comments with awkward media references.</p>

<h2>4. Tools<a id="s0:3"></a></h2>


<p>To get started you will need a literate programming tool of which there are many.
I recently wrote one called <a href="https://github.com/justinmeiners/srcweave">srcweave</a> which I used to generate the document you are now reading.
I previously used <a href="https://zyedidia.github.io/literate/">Literate</a> which is still a great system.</p>

<p>For aspiring grand-masters there is also <a href="https://ctan.org/tex-archive/systems/knuth/dist/web?lang=en">Knuth&rsquo;s WEB</a>.
The <a href="(https://ctan.org/tex-archive/systems/knuth/dist/tex?lang=en)">TeX source</a> is written in it and available to read.</p>
</body>
</html>
