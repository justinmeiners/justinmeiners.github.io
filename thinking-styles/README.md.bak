Thinking styles in math
==========================

A surprising lesson I learned from graduate school is that math is just very different than everything else I have tried learning in the past.
It has it's own style of thinking that has grown to be my [primary method](/think-in-math/) for solving hard problems. 
But, coming from a background in professional software development for years before, I expected a lot more of the core engineering skills to carry over.

For example, to debug programs my experience  taught me to use a radically empirical approach.
When something isn't working as expected, I "turn off" that part of my brain that makes assumptions about what it should be doing, and just directly examine the behaviour of the program.
Usually it starts with, "does this line ever get called?", and grows increasingly more skeptical, "does 2+2 really equal 4?".
When the problem is tricky, no question is too stupid to ask.
The goal is to quickly find the gap in my mental model and accomodate it.
It's a simplfied version of the scientific method, with a bit of a bias towards experimenting over hypothesizing.

Beginners struggle with debugging because their understanding of the language is shaky to begin with. Perhaps this makes it  uncomfortable for them to question or change much. From their rigid perspective the computer just does impossible or magical things and they just try stuff.

This skill of "turning off" your judgement and only observing gets you almost nowhere in math.
Proving a theorem is all about building up new information from facts you know.
You have to look at it an object and assert with confidence, "This fits into X category. I know X category has this property. Therefore... ".
It's an active thinking process that takes constant energy and work.
Furthmore, you have to constantly make assumptions despite the worry that they might be mistaken.
To get better at it, you either learn the material more thouroughly so you can assert with more confidence,
or perform logical checks along the way to verify assumptions.
It's the opposite of a humility.

Even though it takes a lot of work, then end result is very satisfying.
Each math problem requires you to demonstrate that you know something in the truest way possible.
You don't just happen to hold a true opinion, but can construct, at progressing levels of detail, an explanation for why it's true.

There is still an experimental aspect to math, and some mathematicians are much more experimental than others.
When you don't know where to go, you construct and study examples and try to discern some pattern that explains what's going on.
But, it's also much more engaged than passive observation, as you must be the one to think up the examples, instead of letting the computer work.
Usually the key discovery is made in a sudden flash of insight, after a lot of thought and experimentation.
However discoveries can also be made gradually, as conjectures are refined over time.

Despite some experimentation, this process certainly isn't like engineering.
Determing goals, evaluating tradeoffs, creating plans, proving solutions step by step; these skill just don't seem to apply much here.

There is an alterative theory that programming is more like a craft than engineering, like wordworking, writing, or [painting](http://www.paulgraham.com/hp.html).
The artist starts with a rough outline or plan, and then gradually refines portions of the work, making corrections and changes across the entire piece as they go.
Once again, I see very few parallels with math.
There is little hope to transform a false result into a true one, or to discover new insights with highly local incremenetal improvements.

Why is there such a big gap in experiences?
It's hard to say.
Math is certainly more focused on discovery and questioning what is true, as opposed to constructing something.
This suggests a more direct encounter with constraints imposed by the world.
But, even this distinction isn't very clear, as the world imposes constraints on engineering in a similar way.

All of this has challenged my belief in meta-learning.
There is an idea that all fields are pretty much the same, except for details, and you can just transfer skills between them.
Perhaps you have heard the goal of university is to teach you "how to learn".
That just doesn't appear completely true.
Some things are similar enough for a transfer, but some are just different.

Of course, it's always possible there is a generalization of ideas, that subsumes multiple or even all fields.
Business and finance is a generlization of individual enterprises that seem to work pretty well.
But I haven't seen a meta-learning framework described at that level of generality.

There are some meta-learning skills that are used in math which are hugely underrated in engineering and especially software.
One I have previously overlooked is deliberate practice combined with feedback or coaching.
It's popular in a lot of other fields.
But engineers argue that most of their time and energy is spent on tasks that are not repeatable or practicable; conceptualizing the problem, gathering requirements, etc. 
Therefore, they can't be optimized.
Furthermore, it doesn't make sense to optimize lower-level implementation skills as they aren't the main budget of time.
Dan Luu has [responded](https://danluu.com/productivity-velocity/) to this, arguing that increased velocity significantly aids the other tasks, including simply being able to try more iterations in the same amount of time.
His article is worth reading to get all the detail.

I just want to add that math has been built up almost entirely of unique breakthroughs and discoveries, which rarely are the same as what's come before.
In other words, the solutions are even less repurposable than what engineers deal with.
Yet, mathematicians place signficiant weight in memorization, practice, coaching, and studying a variety of mathematical areas.

There are a few rationales for this.
Of course, they want to emulate the experience of actually making a mathematical discovery (although real research is mush less well-defined than what appears in the classroom).
But making new breakthroughs is just easier if you are fluent with lower level concepts.
It's hard to do calculus, if you struggle with algebra.

Mathematicians also believe that the techniques used for old problems will become useful again sometime future.
Even if you  never reproduce them exactly, they give you a toolbox and inspiration, to draw from. 
You may have noticed in college that math professors tend to have a "nack" for knowing what to try on a problem.
They seem to get right to the core issue while you are left thinking "I would never have thought of that".
Although it may appear that they must have known the answer, it's actually their trained intuition, built up from being required to solve a lot of problems in a short amount of time.

What would it like to adopt similar practices in programming?
Of course, we should look at speed of writing code, employing explicit processes, workspace improvements, etc.
Coaching suggests a whole set of opprotunities to be tested.
But, I think at a more fundamental basic level it starts with mindset.
There seems to be an attitude of avoiding learning at all costs, for the sake of productivity.
Why don't we embracing curiousity and practice as a separate and worthwhile activity?
You should know how to write a linked list or write a reduce function, off the top of your head.
You should know what's in the standard library you use.
Besides fluency, make a systematic study of the programs that have come before.
What techniques did they use, where did they succeed and fail?







