<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
<title>Justin Meiners</title>
<description>Welcome to my personal site about programming, mathematics, and philosophy!</description>
<link>https://justinmeiners.github.io</link>
<lastBuildDate>Sat, 12 Sep 2020 10:33:10 -0600</lastBuildDate>
<item>
<pubDate>Sat, 12 Sep 2020 00:00:00 -0600</pubDate>
<title>Gesture Recognition with Line Integrals</title>
<guid isPermaLink="true">https://justinmeiners.github.io/gesture-recognition/</guid>
</item>
<item>
<pubDate>Sun, 24 May 2020 00:00:00 -0600</pubDate>
<title>Boring Benefits of Lisp</title>
<guid isPermaLink="true">https://justinmeiners.github.io/boring-benefits-of-lisp/</guid>
<description><![CDATA[ 
 <h1>Boring Benefits of Lisp</h1>

<p>Lisp advocates are famous for having extravagant reasons for why Lisp is their favorite language.
You might have heard that its the <a href="http://www.paulgraham.com/avg.html">most powerful language</a>,
due to feature like <a href="http://www.paulgraham.com/onlisp.html">macros</a> or <a href="https://en.wikipedia.org/wiki/Homoiconicity">homioconicty</a>.
Certainly, Common Lisp and Scheme have no shortage of beautiful ideas,
but due to their influence, most of their benefits have now been included
in modern languages, and as you may know fancy language abstractions <a href="https://justinmeiners.github.io/think-in-math/">don&rsquo;t
appeal to me</a>.
I am now interested in it for very simple and practical reasons;</p>

<ol>
<li>Lisp is a fully standardized language. Consequently, it is well understood, cross-platform, and has multiple implementations, including several with free licenses.</li>
<li>Lisp has great documentation, books, and learning resources. SICP is &ldquo;the book&rdquo; for Scheme. Common Lisp has several good ones.</li>
<li>Lisp is mature and extremely stable. Code be written once, and run again years later, without modification.</li>
<li>Lisp implementations are reasonably fast. The true believers claim Common Lisp is as fast as C. In general it&rsquo;s not even close, but for a high-level, dynamic, language, <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/lisp.html">it&rsquo;s pretty fast</a>.</li>
<li>Lisp is well designed and follows solid computer science principles.
It has a focused selection of features and an elegant evaluation model which make it easy to
write and compose functionality.</li>
</ol>


<p>These features don&rsquo;t appear too remarkable or unique to Lisp.
In fact, this pattern of requirements was actually established by ANSI C first, and later adopted by Lisp.
But, the surprising thing is how few languages since have followed the pattern.
Of course satisfaction lies on a spectrum; some languages do more than others,
but very few follow it to a degree that can be asserted with confidence.
Usually, you can say a language somewhat satisfies it, followed by a list of ugly qualifications.</p>

<p>Take Python for example. It&rsquo;s well designed, has great resources, is fairly stable.
It has an <a href="https://norvig.com/python-lisp.html">elegant design</a> like Lisp.
But, is it standardized? Kind of, they have a spec, but it has one defacto implementation.
CPython does whatever they want, and others follow along.
The alternative implementations all have compatibility compromises.
Neither is it fast, unless you use a [JIT] implementation which makes it tolerable,
but that has its own quirks, and you can&rsquo;t use many libraries with it.</p>

<p>So are Lisp and C the only languages that do this? No, but there aren&rsquo;t as many as you think.
Lisp just happens to be one of them, and it&rsquo;s a design that I enjoy using and learning about.</p> 
 ]]></description>
</item>
<item>
<pubDate>Sun, 12 Apr 2020 00:00:00 -0600</pubDate>
<title>10 Hard Decisions: A Model for Programmer Productivity</title>
<guid isPermaLink="true">https://justinmeiners.github.io/10-hard-decisions/</guid>
<description><![CDATA[ 
 <h1>10 Hard Decisions: A Model for Programmer Productivity</h1>

<p>How do you ensure that programmers are using time effectively?
What can you do to help them be productive?
Managers think a lot about these questions.
But too often they get the answers wrong despite being very earnest and smart.
This is because they have an unexamined mental model of how programming work is actually done.
With an inaccurate model, managers optimize the wrong things and make bad decisions
which would otherwise be good decisions in other work environments.</p>

<p>To understand the idea, let&rsquo;s look at a few examples of how productivity varies between jobs.
Simple manual labor, like digging holes, is easy to understand.
Productivity comes down to moving as much dirt per minutes as possible.
Progress is very measurable, and it easy to think about how to improve it.
As a manager, you might ensure there is a rotation of workers digging at all time,
and that everyone has the best tools possible.
However that looks very different than the working model for a professional baseball scout.
A scout can take a few years of evaluating players just to find one great pro.
There aren&rsquo;t simple metrics you can use to measure their progress.
It&rsquo;s hard to tell exactly what productive work should look like.
Exposure to a lot of players can help, but ultimately it comes down to a few big choices.</p>

<p>What kind of work is programming most like?
In my experience (especially in agencies), the typical
model of a programmer is an expensive factory machine.
This is the kind of machine that occupies a lot of space and attention in the factory.
It&rsquo;s operation is fragile, so it needs to be constantly checked on and maintained.
But most importantly, every minute that it is not working on jobs is expensive money wasted.
The primary metric for ensuring it stays productive is utilization time, even if that means spending time
on throw away jobs.</p>

<p>Managers understand this work model very well, perhaps they read &ldquo;The Goal&rdquo; in school.
They look for metrics to identify throughput and bottlenecks and do lots of shuffling of programmers
around to ensure maximum utilization.
In it&rsquo;s most exaggerated form this led managers to obsess over metrics &ldquo;lines of code per week&rdquo;.
Although we have moved beyond that.
The underlying thinking about what&rsquo;s going on has changed much.
We just think about programmers as feature producers.
The task the programmer needs to finish programmer needs to sit at the computer and type in the project.</p>

<p>Here is a common example of this thinking: Bob is busy finishing task 1 and then will start project 2.
Alice has a bit of downtime before she starts project 3.
Let&rsquo;s have Alice get started on project 2, then we can
have her hand off the incomplete work to Bob.
In a few weeks when he is ready, Alice can move on to project 3 and leave Bob with a head start.</p>

<p><img src="timeline.png" alt="sample timeline" /></p>

<p>This seems like smart move.
We made sure that Alice and Bob&rsquo;s valuable time was well used, right?</p>

<h2>A better Model</h2>

<p>To see why this decision may actually waste time, we need
a better understand what programming is like.
The model I will describe is not perfect, it&rsquo;s a great simplification, but
its a rough estimation that&rsquo;s far more accurate than the factory machine one.
That better model is the following:
<strong>each project consists of making 5-15 difficult software decisions</strong>.
All of these decisions are of course somewhat dependent on one another.
Each of those decisions that is made well, will lead to shipping the project,
Each decision made wrong, will cause delays and waste time, now or down the road.
That&rsquo;s all. That&rsquo;s the description of the job programmers need to do,
and how they occupy their time.
If programmers knew what to write beforehand, they could type it in no time!
The time they spend fiddling at the keyboard is actually gather information
through experiment and observation, in order to make decisions.</p>

<p>As a manager, the way to improve productivity
is to simply think about what would help you make hard decisions.
Here are some simple ideas that become immediately obvious, given this clearer model:</p>

<ul>
<li><p>Give programmers as much possible information about the project as early as possible.
It&rsquo;s difficult to make decisions with incomplete information.
When you get ideas early they can sit in the back of your mind and get some sleep
time.  Organize information so its easy to process.</p></li>
<li><p>Protect programmer time from interruptions.
Design large blocks of uninterrupted time.
Have quiet working environments.
It&rsquo;s hard to make good decisions without focus.
Other writers have written extensively about the cost of &ldquo;<a href="http://www.paulgraham.com/makersschedule.html">context switching</a>&rdquo;
when you have to forget about what you were thinking and start thinking about something new.</p></li>
<li><p>Ensure programmers have a clear understanding of project priorities and goals.
Clearly communicate expectations and requirements.
Making good decisions requires making trade-offs.
Unclear priorities will lead to programmers making bad decisions.
Changing priorities will invalidate previously good decisions.</p></li>
<li><p>It&rsquo;s OK if a programmer is not at their keyboard writing code.
Taking a walk or a rest is often productive time.
Distracting activities like watching a lot YouTube are not.</p></li>
<li><p>Don&rsquo;t treat programmers interchangeably.
Give them ownership of specific project pieces so they can make long term decisions and build on previous ones.
Would you hire a separate architect to design each room of a house?</p></li>
<li><p>Ensure your incentive structure rewards good decision making.
Do you reward band-aid approaches? Are programmers just trying to get it &ldquo;over the fence&rdquo;
so someone else has to deal with it? Are programmers are the receiving side of the fence?</p></li>
<li><p>Going through a crunch? <a href="https://en.wikipedia.org/wiki/Brooks%27s_law">Don&rsquo;t add people</a> to a late project. Throw more money and effort at building an focused environment to making decisions. Can you pay someone to errands at home so the programmer doesn&rsquo;t have to think about them? Can you bring their family to the office for a lunch? (1)</p></li>
</ul>


<p>This is just a short list of suggestions and you can probably can come up with even better
ideas.
What&rsquo;s important is that as we think deeper about this model common productivity mistakes become apparent. (2)</p>

<p>Let&rsquo;s analyze the Bob and Alice example again using this model.
Did we help Alice and Bob make decisions or hurt them?
Recall, Alice starts working on task 2 for a few weeks, to get it started for Bob.
Then Bob picks it up, and Alice moves elsewhere.
In our rough model we can assume that when Alice finishes, she has made 2 of the 15 decisions, and has some vague ideas about 5 others.
The manager arranges a meeting for Alice to inform Bob of her work and she is swept off to task 3.
Now Bob has to start thinking about task 2 from scratch, but not only that,
he has to figure out what Alice was up to, whether the decisions she made were right,
and what direction she was heading to address the other 13 decisions.
This added information causes Bob to take more time than if he had started on his own.
In practice, its even worse because Alice and Bob will need to continue to take time from each other to coordinate about what Alice had in mind. (3)</p>

<h2>Smarter Alternatives</h2>

<p>You might say, &ldquo;that makes sense, but what am I supposed to do? Let Alice sit around for a week, wasting that time with an urgent project?&rdquo;. Let&rsquo;s use the model to work through better options.
In this scenario Alice is scheduled to eventually own project 3.
A better option would be to just let task 2 sit until Bob is ready, and get her stated on her project, even though it may be less urgent.
Alice will be able to spend more time thinking about her project, and leave Bob with a fresh slate.</p>

<p>&ldquo;But this is really urgent, I don&rsquo;t even want to think about project 3 yet&rdquo;.
The next alternative would be to identify decisions which Alice can make which have the least impact on the other work Bob needs to do.
One would be having Alice better define the requirements and organize resources for this project.
This will only help Bob make his decisions.
Another idea is to have Alice work on &ldquo;black boxes&rdquo; that Bob doesn&rsquo;t need to know how they work.
Maybe Alice has some special knowledge and can write a hard function he expects to use.
What you absolutely don&rsquo;t want to do is interrupt Bob and have him start thinking about what decisions Alice could be making, while he is making his decisions.
That doesn&rsquo;t make any sense!</p>

<h2>Notes</h2>

<ol>
<li><p>I don&rsquo;t think programmers <em>deserve</em> any of these special treatments over other jobs.
I am not suggesting that programmers should have special privileges or are somehow more important than other kinds of work.
It&rsquo;s all about the productivity model for the kind of work they do.</p></li>
<li><p>In video game production, art tends to be easy to outsource while programming is notoriously difficult and often unsuccessful. Perhaps this is because 3D art production can be better fit into a factory production productivity model.</p></li>
<li><p>One reason &ldquo;just write it from scratch&rdquo; is so appealing for programmers is that
they get to make their own decisions, instead of figuring out why others made (often bad) decisions.
Who wants to live with someone elses choices?
For large existing codebases this represents a lot of invested knowledge, so its usually bad,
but for a new task, Why would you rob a programmer of this opportunity by playing
musical chairs?</p></li>
</ol> 
 ]]></description>
</item>
<item>
<pubDate>Thu, 23 Jan 2020 00:00:00 -0600</pubDate>
<title>Keeping Up-to-Date</title>
<guid isPermaLink="true">https://justinmeiners.github.io/keeping-up-to-date/</guid>
<description><![CDATA[ 
 <h2>Keeping Up-to-date</h2>

<p><strong>1/23/2020</strong></p>

<p>The software industry is synonmous with rapid innovation.
New discoveries require changing to better ways of doing things.
For programmers to stay relevant they need to constantly keep up on the latest technologies,
otherwise their skills will go out of date.
At least, that&rsquo;s what I&rsquo;ve been told,
but the more I study computer science from 50 years ago,
the more I find &ldquo;new&rdquo; ideas are actually old.
Perhaps the changes we see are only permutations
of underlying ideas.</p>

<p>In many obvious ways software does change.
Languages, libraries, and tools get replaced overtime.
Nobody is writing desktop applications in assembly anymore.
Many developers who wrote Windows applications moved on to mobile or web.
But rarely are these changes due to a technological advancement
or dramatic in change in how things are done, just new forms
of popular products, or improved hardware that gives us some wiggle room.</p>

<p>A good engineer can adapt to these changes, in the same way they can switch
to a company which uses different tools and processes.
Learning Python after C# should be easy, because you understand programs, not the syntax.
Moving to a language with significant design differences like Haskell requires a broader
understanding of functions and computation.
Now imagine there was similar knowledge that helped you approach every computer problem and perhaps
all of nature.
The knowledge I am describing is math and science!
For software it consists of <a href="https://teachyourselfcs.com/">computer science subjects</a> like OS theory, algorithms, software design, logic,
and calculus.
Because many programmers lack this, they struggle with change, and feel pressure
to keep up with trends. (1)</p>

<p>Don&rsquo;t believe me?
Take a look at the hottest &ldquo;new&rdquo; areas of tech
AI/machine learning, blockchain, and big data/data science.
What barriers make it difficult for programmers to get into them and be successful?
For machine learning the answer is a bit of linear algebra and multivariable calculus,
evidenced by the many blog post promising to get readers up to speed.
This math is (should be) covered by every computer science degree
and has remained the same for at least 50 years,
down to the presentations and illustrations used to <a href="https://www.youtube.com/watch?v=wsOoClvZmic">teach it</a>.
<a href="https://justinmeiners.github.io/neural-nets-sim/">Neural networks</a> themselves have been around for a <a href="https://en.wikipedia.org/wiki/Perceptrons_(book)">long time</a>,
although less mainstream.</p>

<p>For <a href="https://justinmeiners.github.io/tiny-blockchain/">blockchain</a> the essentials are an understanding of cryptography,
and peer-to-peer networking. That doesn&rsquo;t even mean fancy understandings
of elliptic curves or number theory, just a solid grasp of hashes,
signatures, and asymetric key encrpytion.
Distributed systems is also a mature field of computer science.</p>

<p>Data science might be the most accessible.
A solid understanding of introductory probablity and statistics and databases
combined with a few tools such as linear regression, and polynomial interpolation
might be enough for 90% of applications.
But it&rsquo;s going to be really hard, if you can&rsquo;t understand a wikipedia page about <a href="https://en.wikipedia.org/wiki/Horner%27s_method">polynomials</a>.</p>

<p>I don&rsquo;t mean to suggest that these skills make an expert.
General theory is a longshot from research or novel contributions to the field.
Nor is it sufficient to be a good programmer; learning linear algebra does not immediately
make you good at writing machine learning programs (and scientists write some terrible code!).
Rather this is the &ldquo;hard stuff&rdquo; that prevents programmers from getting into these fields.
Once you know it, the other details are approachable. (2)</p>

<p>If you analyze other software advances from the past, from database theory
to graphics, you will find similar applications
of rather unextraordinary math and science.
Many programmers ask, how I can I predict what skills will be important in the future?
What do I need to learn to have a successful career?
Few can predict what specific trends will take off, but I
bet whatever is important in the future is going to require understanding
those broad areas of computer science.
Keep practicing and specializing in the area you work in, but if you regularly refresh and
broaden your base of fundamentals
you will be prepared to learn anything new that starts to look interesting. (3)</p>

<p>Understanding fundamentals gives programmers another significant advantage.
They know what problems have been solved before.
It&rsquo;s unlikely you will remember every detail, but can say
&ldquo;I&rsquo;ve heard of this before&rdquo; and know where to learn more.
Consider how many new tools are bad solutions to problems solved by simple bash scripts,
of which the author was ignorant of.
This is just a tiny represenative of how much duplication and complexity
programmers are adding because they don&rsquo;t know whats already there.</p>

<p>It may sound as though I am advocating a kind of tech hipsterism;
everything interesting has already been done so we might
as well stop looking for new things. Rather I am arguing
that we will be able make more advancements, if we better
understand the big ideas behind what has come before.</p>

<p>Properly understood this flips the progress narrative of technology on it&rsquo;s head.
We don&rsquo;t have to chase headlines and blog posts about the latest frameworks
and build tools.
Nor do we have to guess which technologies might suddenly become useful, like day trading stocks.
That&rsquo;s for evangelists and IT consultants.
The foundations for our next ideas has have already been built by generations of smart people.
It&rsquo;s all written down waiting to be dusted off and rediscovered.
Rather than building and encyclopediac knowledge of novelties
 and press releases,
we continuosuly revisit the same core subjects, over and over, in pursuit of mastery.</p>

<ol>
<li><p>It doesn&rsquo;t have to come from a university, and a majority
of those who study STEM seem to lose it after going through the motions.</p></li>
<li><p>A great example of this is the
popular book <a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html">SICP</a>. In just a few hundred
pages it covers several major areas of CS and more
than most programmers understand in their whole career.
It&rsquo;s able to do that because it&rsquo;s not written
for a general audience.
It relies on the reader having a solid undergraduate understanding of another
area of math or science as an MIT student would have.</p></li>
<li><p>Experts in a very particular system
(for example OpenCL or <a href="https://v8.dev/blog">V8 internals</a>) can be extremely valuable.
But, most of them only get that level of depth with a solid
understanding of fundamental computer science.
Expertise is also a subject for another day.</p></li>
</ol> 
 ]]></description>
</item>
<item>
<pubDate>Wed, 18 Dec 2019 00:00:00 -0600</pubDate>
<title>Shamans: A 3D Turn-based Strategy Game for iPad</title>
<guid isPermaLink="true">https://justinmeiners.github.io/shamans/</guid>
</item>
<item>
<pubDate>Sun, 28 Jul 2019 00:00:00 -0600</pubDate>
<title>Write Your Own Proof-of-Work Blockchain</title>
<guid isPermaLink="true">https://justinmeiners.github.io/tiny-blockchain/</guid>
</item>
<item>
<pubDate>Sat, 29 Jun 2019 00:00:00 -0600</pubDate>
<title>text2image</title>
<guid isPermaLink="true">https://github.com/justinmeiners/text2image</guid>
</item>
<item>
<pubDate>Sat, 08 Jun 2019 00:00:00 -0600</pubDate>
<title>Think in Math. Write in Code.</title>
<guid isPermaLink="true">https://justinmeiners.github.io/think-in-math/</guid>
<description><![CDATA[ 
 <h2>Think in Math. Write in Code.</h2>

<p><strong>6/8/19</strong></p>

<p>Programmers love to discuss programming languages.
We not only debate their technical merits and aesthetic qualities,
but they become integrated into our personal identities,
along with the values and traits that we associate with them.
Some even defend a form of <a href="https://en.wikipedia.org/wiki/Linguistic_determinism">Linguistic Determinism</a> that thinking is confined to what the language
makes typable.</p>

<p>Since we spend so much time writing code, a keen interest in language design is justified.
However, the character of these discussions suggests that we think of them as much more,
and have perhaps forgotten their primary role.
Programming languages are <em>implementation tools</em> for instructing machines, not <em>thinking tools</em>
for expressing ideas.
They are strict formal systems riddled with design compromises and practical limitations.
At the end of the day, we hope they make controlling computers bearable for humans.
In contrast, thoughts are best expressed through a medium which is free and flexible.</p>

<h2>Thinking in Math</h2>

<p>The natural language which has been effectively used for thinking about computation, for thousands of years, is mathematics.
Most people don&rsquo;t think of math as free or flexible.
They think of scary symbols and memorizing steps to regurgitate on tests.
Others hear math and think category theory, lambda calculus, or other
methods of formalizing computation itself, but these are hardly
necessary for programming itself.</p>

<p>I hope readers of this article have had a better experience regarding what math is about, such as a graph theory, algorithms, or linear algebra course;
the kind that involves logic and theorems, and is written in prose with a mix of symbols (most symbols weren&rsquo;t even invented until the <a href="https://en.wikipedia.org/wiki/History_of_mathematical_notation#Symbolic_stage">16th century</a>).
This kind of math is about creating logical models to understand real world problems, through careful
definitions and deductions.
If you don&rsquo;t have a clear idea of what this looks like I recommend <a href="https://www.amazon.com/Introduction-Graph-Theory-Dover-Mathematics/dp/0486678709">Trudeau</a>,
<a href="https://www.fm2gp.com">Stepanov</a>, or <a href="https://www.amazon.com/Introduction-Algorithms-Creative-Udi-Manber/dp/0201120372">Manber</a>.</p>

<p>Math allows you to reason about logical structures, free from other constraints.
This is also what programming requires: creating logical systems to solve problems.
Take a look at the basic pattern for programming:</p>

<ol>
<li>Identify a problem</li>
<li>Design algorithms and data structures to solve it</li>
<li>Implement and test them</li>
</ol>


<p>In practice, work is not so well organized as there is interplay between steps.
You may write code to inform the design.
Even so, the basic pattern is followed over and over.</p>

<p>Notice that steps 1 and 2 are the ones that take most of our time, ability, and effort.
At the same time, these steps don&rsquo;t lend themselves to programming languages.
That doesn&rsquo;t stop programmers from attempting to solve them in their editor, but they end up with code that is muddled, slow, or that solves the wrong problem.
It&rsquo;s not that programming languages aren&rsquo;t good enough yet.
It&rsquo;s that <em>no formal language</em> could be good at it.
Our brains just don&rsquo;t think that way.
When problems get hard, we draw diagrams and discuss them with collaborators.</p>

<p>Ideally, steps 1 and 2 are solved first, and only then will a programming language be used to solve step 3.
This has an added benefit of transforming the implementation process.
With a mathematical solution in hand, you can then focus on choosing the best representation and implementation, and writing better code, knowing what the end goal will be.</p>

<h2>Implementation Concerns</h2>

<p>Why are programming languages burdensome thinking tools?
One reason is that writing code is inseparably connected with implementation concerns.
A computer is a device that must manage all kinds of tasks and while being bound by physical
and economic constraints.
Think about all the considerations for writing a simple function:</p>

<ul>
<li>What inputs should I provide?</li>
<li>What should they be named?</li>
<li>What types should they be? (Even dynamically typed languages must consider types, it&rsquo;s just implicit.)</li>
<li>Should I pass them by value or by reference?</li>
<li>What file should I put the function in?</li>
<li>Should the result be reused, or is it fast enough to recalculate it every time?</li>
</ul>


<p>The list can go on. The point is that these considerations have nothing to do with what the function does.
They distract from the problem the function is trying to solve.</p>

<p>Many languages aim to hide details such as these, which is helpful, especially for mundane tasks.
However, they cannot transcend their role as an implementation tool.
SQL is one of the most successful examples of this, but it is ultimately concerned with implementation concerns such as tables, rows, indices, and types.
Because of this, programmers still design complicated queries in informal terms, like what they want to &ldquo;get,&rdquo; before writing a bunch of <code>JOIN</code>s.</p>

<h2>Inflexible Abstractions</h2>

<p>Another limitation of programming languages is that they are poor abstraction tools.
Typically, when we discuss abstraction in engineering, we mean hiding implementation details.
A complex operation or process is packaged into a &ldquo;black box&rdquo; with its contents hidden and well-defined inputs and outputs exposed.
Accompanying the box is fictional story that explains what it does, in a greatly simplified way.</p>

<p><img src="black-box.gif" alt="black box picture" /></p>

<p>Black boxes are essential for engineering large systems since the details are too overwhelming to hold in your head.
They also have many well-known limitations.
A black box <a href="https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/">leaks</a> because its brief description cannot completely determine its behavior.
The opaque interfaces introduce <a href="https://www.youtube.com/watch?v=lHLpKzUxjGk">inefficiencies</a>, like duplication and fragmented design.</p>

<p>Most importantly for problem-solving, black boxes are rigid.
They must explicitly reveal some dials and knobs, and hide others,
committing to a particular view about what it is essential to expose to the user,
and what is noise.
In doing so, they present a fixed level of abstraction which may be too high-level or too low-level for the problem,
As an example, a high-level web server may provide a terrific interface for serving JSON, but be useless if one wants an interface for serving incomplete data streams, such as output from a program.
In theory, you can always look inside the box, but in code, the abstraction level at any one time is fixed.</p>

<p>In contrast, the word abstraction in math is nothing like hiding information.
Here, abstraction means extracting the essential features or characteristics of something, in relation to a particular context.
Unlike black boxes, no information is hidden.
They don&rsquo;t leak in the same way.
You are encouraged to adjust to the right level of abstraction and quickly jump between perspectives.
You might ask:</p>

<ul>
<li>Is this problem best represented as a table? Or, a function?</li>
<li>Can I look at the whole system as a function?</li>
<li>Can I treat this collection of things as a single unit?</li>
<li>Should I look at the whole system or a single part?</li>
<li>What assumptions should I make? Should I make them stronger or weaker?</li>
</ul>


<p>Just look at the many ways of looking at a function:</p>

<p><a href="https://www.youtube.com/watch?v=ACZDnF8-9Ks"><img src="functions.gif" alt="function representations" /></a></p>

<p>Thinking in math allows one to use whichever brings the most clarity at any moment.</p>

<p>It turns out most abstract concepts can be understood from many perspectives, just like functions.
Studying math provides one with a versatile toolbox of perspectives for studying all kinds of problems.
You might first describe a problem with a formula, and then switch to understanding it <a href="https://en.wikipedia.org/wiki/Felix_Klein#Erlangen_program">geometrically</a>,
then recognize some group theory (abstract algebra) is at play, and
all of this combines to give insight and understanding.</p>

<p>To summarize, programming languages are great engineering tools for assembling black boxes;
they provide functions, classes, and modules, all of which help wrap up code into nice interfaces.
However, when trying to solve problems and design solutions, what you actually want is the math kind of abstraction.
If you try to think at the keyboard, the black boxes available to you will warp your view.</p>

<h2>Problem Representation</h2>

<p>Just as programming languages are rigid in their ability to abstract, they also are rigid in how they represent data.
The very act of implementing an algorithm or data structure is picking <em>just one</em> of the many possible ways to represent
something; along with all the trade-offs that come with it.
It is always easier to make trade-offs when one has use cases in mind and understand the problem well.</p>

<p>For example, graphs (sets of vertices and edges) appear in many programming problems such as internet networks, pathfinding, and social networks.
Despite their simple definition, choosing how to represent them is hard and varies greatly depending on use case:</p>

<p><img src="graph.gif" alt="math graph" /></p>

<ul>
<li><p>The one which most closely matches the definition:<br/>
<code>vertices: vector&lt;NodeData&gt; edges: vector&lt;pair&lt;Int, Int&gt;&gt;</code>
(The vertices can be removed if you only care about connectivity.)</p></li>
<li><p>If you want to traverse a node&rsquo;s neighbors quickly, then you probably want a node structure:<br/>
<code>Node { id: Int, neighbors: vector&lt;Node*&gt; }</code></p></li>
<li><p>You could use an <a href="https://en.wikipedia.org/wiki/Adjacency_matrix">adjacency matrix</a>. Where each row stores the neighbors of a particular node:
<code>connectivity: vector&lt;vector&lt;int&gt;&gt;</code> and the nodes themselves are implicit.</p></li>
<li><p>Pathfinding algorithms often work on graphs implicitly from a board of cells:<br/>
<code>walls: vector&lt;vector&lt;bool&gt;&gt;</code>.</p></li>
<li><p>In a peer-to-peer network, each computer is a vertex and each socket is an edge.
The entire graph isn&rsquo;t even accessible from one machine!</p></li>
</ul>


<p>Math allows you to reason about the graph itself, solve the problem, and then choose an appropriate representation.
If you think in a programming language, you cannot delay this decision as your first line of code commits to a particular representation.</p>

<p>Note that the graph representations are too diverse to wrapped up in a polymorphic interface.
(Consider again the graph representing a computer network, like the entire internet.)
So creating a completely reusable library is impractical.
It can only work on a few types, or force all graphs into an inappropriate representation.
That doesn&rsquo;t mean libraries or interfaces aren&rsquo;t useful.
Similar representations are needed again and again (like <code>std::vector</code>),
but you cannot write a library which encapsulates the concept of &ldquo;graph&rdquo; once and for all.
A simple generic or interface with a few types in mind is appropriate.</p>

<p>As a corollary, programming languages should focus primarily on being useful implementation tools,
rather than theoretical tools.
A good example of modern language feature which does this is async/await.
It&rsquo;s not hiding away complex details or introducing new conceptual theory.
It takes a common practical problem and makes it easier to write.</p>

<p>Thinking in math also makes the &ldquo;C style&rdquo; of programming more appealing.
When you understand a problem well, you don&rsquo;t have to build up layers of framework and abstraction
in anticipation of &ldquo;what if&rdquo;.
You can write a program tailor made to the problem, with carefully chosen trade-offs.</p>

<h2>Example Project</h2>

<p>So what does thinking in math look like?
For this section you may have to read a bit more slowly and carefully.
Recently, I worked on an API at work for pricing cryptocurrency for merchants.
It takes into account recent price changes and recommends that merchants charge a higher price during volatile times.</p>

<p>Although we did some homework on the theory, we wanted to empirically test it to see how it performed during various market conditions.
To do so, I designed a bot to simulate a merchant doing business with our API, to see how it performs.</p>

<p><strong>BTC/USD (1 day)</strong></p>

<p><img src="btc-usd.gif" alt="btc usd" /></p>

<h3>Preliminaries</h3>

<p><strong>Definition:</strong> The <strong>exchange rate</strong> <code>r(t)</code> is the market rate of <code>fiat/crypto</code>.</p>

<p><strong>Definition:</strong> The <strong>merchant rate</strong> <code>r'(t)</code> is the modified exchange rate which the merchant is advised to charge customers.</p>

<p><strong>Definition:</strong> When a customer buys an item, we call that event a <strong>purchase</strong>.
A purchase consists of the price in fiat and a time. <code>p = (f, t)</code>.</p>

<p><strong>Theorem:</strong> The amount of crypto for a purchase is found by applying the modified exchange rate
<code>t(p) = p(1) / r'(p(2))</code>.</p>

<p><strong>Proof:</strong> <code>p(1) / r'(p(2)) = fiat / (fiat/crypto) = fiat * crypto/fiat = crypto</code></p>

<p><strong>Definition:</strong> When the merchant sells their crypto holdings, we call that event a <strong>sale</strong>.
A sale consists of an amount in crypto and a timestamp. <code>s = (c, t)</code>.</p>

<p><strong>Theorem:</strong> The amount of fiat the merchant obtained from a sale is found by applying the exchange rate to the sale <code>g(s) = s(1) * r(s(2))</code>.</p>

<p><strong>Proof:</strong> <code>s(1) * r(s(2)) = crypto * (fiat/crypto) = fiat</code></p>

<p><strong>Definition:</strong> The <strong>balance</strong> of a set of purchases and sales is the difference between all purchase crypto amounts and all sale crypto amounts.
 <code>b(P, S) = sum from i to N of t(p_i) - sum from j to M of s_j(1)</code></p>

<p>Note that <code>b(P, S) &gt;= 0</code> must always hold.</p>

<p><strong>Definition:</strong> The <strong>earnings</strong> of a set of purchases and sales is the difference between sale fiat amounts and purchase fiat amounts.
<code>e(P, S) = sum from j to M of g(s_j(1)) - sum from i to N of p_i(1) &gt;= 0</code>.</p>

<h3>Objective</h3>

<p><strong>Definition:</strong> We say that the merchant rate is <strong>favorable</strong> iff the earnings are non-negative for <em>most</em> sets of <em>typical</em> purchases and sales.
<code>r'(t) is favorable iff e(P, S) &gt;= 0</code>.</p>

<p>In a favorable case, the merchant didn&rsquo;t lose any fiat by accepting crypto.</p>

<p><em>most</em> and <em>typical</em> will not be rigorously defined.</p>

<p>As part of <em>typical</em>, we can assume that merchants will sell their crypto in a timely manner.
So assume <code>s_i(2) - s_j(2) &lt; W</code> for <code>i,j in {1.. M}</code> for some bound <code>W</code>.
Purchase amounts should be randomly distributed within a reasonable range that commerce is done. Perhaps $10-100.</p>

<p><strong>The goal of the bot is to verify that <code>r'(t)</code> is favorable.</strong></p>

<p>Note that this definition is only one measure of quality.
Perhaps protecting against the worst case is more important than being favorable.
In that case, we would be concerned about the ability to construct a set of purchases with very negative earnings.</p>

<h3>Algorithm</h3>

<p>Repeat many times:</p>

<ol>
<li>Randomly choose a time range <code>[t0, t1]</code>.</li>
<li><p>Generate a set of <strong>purchases</strong> at random times within <code>[t0, t1]</code>.
The price should fall within a range <code>[p0, p1</code>] of <em>typical</em> prices.</p></li>
<li><p>Generate a set of <strong>sales</strong> at evenly spaced times (perhaps with slight random noise) within <code>[t0, t1]</code>.
Each sale should be for the full <strong>balance</strong> at that time.</p></li>
<li>Calculate the <strong>earnings</strong> for these sets.</li>
<li>Record the earnings.</li>
</ol>


<p>After:</p>

<ol>
<li>Report how many earnings were negative and non-negative. Show a percentage for each.</li>
<li>Identify the minimum and maximum earnings and report them.</li>
</ol>


<h3>Conclusion</h3>

<p>As you read this example, I think your tendency may be to think that its statements are obvious.
Certainly, none of these steps are hard.
However, it was surprising to me how many of my assumptions were corrected and how difficult it was to choose an objective definition of a <strong>favorable</strong> outcome.
This process helped me become aware of assumptions I would not have even considered if I had started by simply writing code.
Perhaps the greatest benefit was that after writing it, I was able to quickly review it with a co-worker and make corrections which were easy on paper, but would have been difficult to change in code.</p>

<p>I hope that thinking in the language of math will bring similar benefits to your projects!
Note that this example is only one style of utilizing mathematical thinking.</p> 
 ]]></description>
</item>
<item>
<pubDate>Sun, 12 May 2019 00:00:00 -0600</pubDate>
<title>Notes On Vector Libraries</title>
<guid isPermaLink="true">https://justinmeiners.github.io/vector-libs/</guid>
<description><![CDATA[ 
 <h1>Notes on Vector Libraries</h1>

<p><strong>05/12/2019</strong></p>

<p>A good vector math library is essential for graphics
and simulation programming.
However, implementing one that is flexible, efficient,
and easy to use is difficult.
Due to so many choices, experienced
programmers tend to write their own to accommodate their preference.</p>

<p>In this article I will survey a few of the most popular techniques and offer some design advice.
I will specifically focus on math theory and C implementations.</p>

<h2>Math</h2>

<p>Before diving into the code.
It&rsquo;s helpful to review some of the math
to understand what we are aiming for. One thing to watch for
is operations that can be defined in terms of each other.
Rarely do I see libraries take advantage of this.</p>

<p><strong>Vector Operations</strong></p>

<p>On vectors in <code>R^N</code></p>

<ul>
<li>addition <code>v + w</code></li>
<li>subtraction <code>v - w</code>. Defined by addition: <code>a - b = a + (-b)</code></li>
<li>multiplication <code>v * w</code></li>
<li>scaling <code>a * v</code></li>
<li>normalization. Defined by length and scaling: <code>1/|v| * v</code></li>
</ul>


<p>From <code>R^N -&gt; R</code></p>

<ul>
<li>dot product <code>&lt;v, w&gt;</code></li>
<li>length <code>|v|</code>. Defined by dot product <code>sqrt(&lt;v,v&gt;)</code></li>
<li>angle. Defined by dot product and length <code>acos(&lt;a,b&gt;/|a||b|)</code></li>
</ul>


<p>Only on specific dimension, such as <code>R^2</code> or <code>R^3</code></p>

<ul>
<li>cross product <code>a X b</code></li>
<li>angle (in the plane)</li>
</ul>


<p><strong>Matrix Operations</strong></p>

<p>On all matrices <code>M(n x m)</code></p>

<ul>
<li>addition <code>A + B</code></li>
<li>subtraction <code>A - B</code>
Defined by addition <code>A - B = A + (-B)</code></li>
<li>scaling <code>bA</code></li>
<li>multiplication <code>AB</code></li>
</ul>


<p>On square matrices <code>M(n x n)</code></p>

<ul>
<li>determinant <code>det(A)</code></li>
<li>inverse <code>A^-1</code></li>
</ul>


<p>Between vectors and matrices</p>

<ul>
<li>multiplication <code>Av</code></li>
</ul>


<p>Most programs use 2, 3, and 4
element vectors, and only a few operations
are specific to a given dimension.
So a lot of code can be condensed by writing algorithms
on N dimensional vectors.</p>

<p>Matrix operations are also very general.
But a few should be kept to a specific
dimension (usually 3x3 or 4x4).
You do not want to implement a
general inverse or determinant function.</p>

<h2>1. Simple Structs</h2>

<pre><code>typedef struct
{
    float x, y, z;
} vec3;

vec3 vec3_add(vec3 a, b)
{
    vec3 r;
    r.x = a.x + b.x;
    r.y = a.y + b.y;
    r.z = a.z + b.z;
    return r;  
}
</code></pre>

<p>This works well for smaller programs.
The best part is that expressions look nice (<code>a + 2.0*(b-d)</code>):</p>

<pre><code>vec3_add(a, vec3_scale(2.0, vec_sub(b, c)));
</code></pre>

<p>But, we have to copy this definition for every dimension.
We also have to avoid any algorithms that use
index or iteration.
Matrix vector multiplication gets ugly.</p>

<p>If you only have a few functions that need
indexing and you can index into a pointer to the first member:</p>

<pre><code>vec3 a;
float* v = &amp;a.x;
v[0];
</code></pre>

<p><strong>Examples</strong></p>

<ul>
<li><p><a href="https://github.com/justinmeiners/pre-rendered-backgrounds/blob/master/source/engine/core/vec_math.h">vec math</a></p></li>
<li><p><a href="https://github.com/nothings/obbg/blob/master/src/stb_vec.h">stb vec</a></p></li>
</ul>


<h2>2. Arrays</h2>

<p>For <code>N</code> dimensional vectors
we might try to write functions which
operate on arrays of floats.
This is nice because it does not
introduce another data structure, so
other functions and vector libraries play nice with each other.</p>

<p>Unfortunately, C does not allow you to return
an array from the stack. You can only return a pointer
which must point to some valid region.
So either we do something horrible like <code>malloc</code> in each operation,
or pass in arrays for the return value.
Passing in arrays works, but it destroys the ability
to comfortably write simple expressions such as <code>a + 2.0*(b-d)</code>:</p>

<pre><code>void vecn_add(int n, float* a, float* b, float* ret);

// intermediate results everywhere
float temp[3];
vecn_sub(3, b, d, temp);

float temp2[3];
vecn_scale(3, 2.0, temp, temp2);

float final[3];
vecn_add(3, a, temp2, final);
</code></pre>

<p>Plain arrays may be appropriate for matrices since they are not typically
involved in complex expressions.
Matrices and large vectors, which would be inefficient to copy around
would also be a good use case.</p>

<p>Depending on the application you may not want
to sacrifice performance by introducing loops and branching
into every operation. As long as the dimensions
are input as a literals or macros, the small loops
should be unrolled at compile time.</p>

<p><strong>Examples:</strong></p>

<ul>
<li><a href="https://developer.apple.com/documentation/accelerate/vdsp">Accelerate</a></li>
<li><a href="https://github.com/datenwolf/linmath.h">linmath</a></li>
</ul>


<h2>3. Struct + Union</h2>

<p>A workaround to return an array from a function is to include it in a struct.
The tradeoff is that the size must be fixed and element access is a bit
uglier as it requires at least an extra letter.</p>

<pre><code>typedef struct
{
    float e[3];
} vec3;

vec3 v;
v.e[0] = 1;
</code></pre>

<p>The access syntax can be cleaned up with a union
but, <a href="https://gcc.gnu.org/onlinedocs/gcc/Unnamed-Fields.html">anonymous structs/unions</a>
are a GCC extension and are non-standard.</p>

<pre><code>typedef union
{
    float v[3];
    struct
    {
        float x;
        float y;
        float z; 
    }; 
} vec3;
</code></pre>

<p>This gives you safe iterative access and nice named members,
but it is hard to combine with generic functions.
Either you use functions which operate on the internal arrays
and deal with the intermediate results.
Or, define fixed dimension functions which wrap
the generic ones:</p>

<pre><code>vec3 vec3_add(vec3 a, vec3 b);
{
    vec3 temp;
    vecn_add(3, a.v, b.v, temp.v);
    return temp;
}
</code></pre>

<p>I don&rsquo;t love this option.
If I need to write wrapper functions I might as well go back to method 1
and copy implementations around.</p>

<p><strong>Examples:</strong></p>

<ul>
<li><a href="https://github.com/arkanis/single-header-file-c-libs/blob/master/math_3d.h">Math 3D</a> (See Matrices)</li>
</ul>


<h2>4. Macros</h2>

<p>Some clever macros can help you get the best of both worlds, and
parameterize the scalar types. This can be combined with
an array or union data structure.
But, writing multi-line macros isn&rsquo;t very fun.</p>

<pre><code>#define DEFINE_VEC(T, N, SUF) \
\
void vec##N####SUF##_add(const T *a, const T *b,  T *r) \
{ \
    for (int i = 0; i &lt; N; ++i) \
        r[i] = a[i] + b[i]; \
} \
</code></pre>

<p>Then define the types you need:</p>

<pre><code>DEFINE_VEC(float, 2, f);
DEFINE_VEC(float, 3, f);
DEFINE_VEC(float, 4, f);
</code></pre>

<p>Usage:</p>

<pre><code>vec3f_add(a, b);
</code></pre>

<p>Functions which only apply to a specific dimension
can be defined outside of the macro:</p>

<pre><code>void vec3f_cross(const float* a, const float* b, float* r)
{
    // ...
}
</code></pre>

<p><strong>Examples:</strong></p>

<ul>
<li><a href="https://github.com/datenwolf/linmath.h">linmath</a></li>
</ul>


<h2>Closing Thoughts</h2>

<p>In typical C fashion, I believe it is misguided to try to write
the <em>one true</em> vector library to serve all purposes.
These libraries are bloated and must choose tradeoffs which
don&rsquo;t fit your use case. Instead use the examples
above to write to tailor make vector functions as needed.</p>

<p>For further reading, see <a href="http://www.reedbeta.com/blog/2013/12/28/on-vector-math-libraries/">On Vector Math Libraries</a>.
It focuses on C++ and has a few other handy tips.
You can also read a <a href="https://github.com/arkanis/single-header-file-c-libs/issues/3">discussion</a>
which led to these notes.</p> 
 ]]></description>
</item>
<item>
<pubDate>Sun, 14 Apr 2019 00:00:00 -0600</pubDate>
<title>Foundations of Math Reading List</title>
<guid isPermaLink="true">https://justinmeiners.github.io/foundations-of-math-reading/</guid>
<description><![CDATA[ 
 <h2>Foundation of Math Reading List</h2>

<p><strong>04/13/2019</strong></p>

<p>One of my favorite courses in college was
philosophy of language.
Along with interesting philosphy
it introduced me to the foundations of math project
which has since become one of my
favorite subjects to learn about.</p>

<p>Some of my favorite books of all time come out of this interest.
I wanted to organize a few of these
into a list for others who are interested in the topic.
Note that many good books were left out in favor of the very best.</p>

<p>You will notice a theme in my commentary.
The books I like most are those that don&rsquo;t
shy away from hard technical knowledge, but also
explore the philosophical ideas behind them.</p>

<p>The list is arranged in a progressive sequence
that will help prepare you for the next one.</p>

<h3>Logicomix</h3>

<p>By: <a href="https://www.apostolosdoxiadis.com">Apostolos Doxiadis</a></p>

<p><img src="logicomix.jpg" alt="logicomix" /></p>

<p>Logicomix is actually a comic book!
It tells an engaging historical narrative about the search for the foundations of math
and the birth of analytic philosophy, in the early 20th century.</p>

<p>It introduces you to all the major characters
such as GÃ¶del, Russel, Frege, and Wittgenstein and
motivates the kinds of problems they were trying to solve.
The book also explores how these ideas connect to modern computer science.</p>

<p>It is an absolute joy to read and will give you a taste
of whether this is an interesting subject for you.</p>

<h3>GÃ¶del, Escher, Bach</h3>

<p>By: <a href="https://en.wikipedia.org/wiki/Douglas_Hofstadter">Douglas Hofstadter</a></p>

<p><img src="geb.jpg" alt="godel escher bach" /></p>

<p>You probably have seen this work recommended elsewhere.
GÃ¶del, Escher, Bach really deserves all the praise that it gets.</p>

<p>Hofstadter covers an enormous range of topics
including formal systems, Godel&rsquo;s proof, theory of computation,
programming, molecular biology, and artificial intelligence.
Every topic is presented beautifully and with a lot of philosophical discussion.
In many ways it is an introduction to the big ideas in modern science.
It is written for a general audience and assumes no mathematical background.</p>

<h3>GÃ¶del&rsquo;s Proof.</h3>

<p>By: <a href="https://en.wikipedia.org/wiki/Ernest_Nagel)">James Newman</a> &amp; <a href="https://en.wikipedia.org/wiki/James_R._Newman">Ernest Nagel</a></p>

<p><img src="godels_proof.jpg" alt="godel's proof" /></p>

<p>GÃ¶del, Escher, Bach does a good job of introducing the incompleteness theorem
and discussing its ramifications, but if you are like me you probably still won&rsquo;t
completely understand it after a first reading.</p>

<p>This concise book offers another perspective and a clear explanation
of the mathematics of the proof, its general strategy, and the
historical context surrounding the incompleteness problem.</p>

<h3>Descartes Dream</h3>

<p>By: <a href="https://en.wikipedia.org/wiki/Philip_J._Davis">Phillip Davis</a> &amp; <a href="https://en.wikipedia.org/wiki/Reuben_Hersh">Reuben Hersch</a></p>

<p><img src="descartes_dream.jpg" alt="descartes dream" /></p>

<p>In the 17th century Descartes had a dream in which he saw
a future world driven by mathematical calculations and logical systems.
The theme of this book is how this dream has become a reality.</p>

<p>The book explores how mathematics and computer science work together,
surveys several interesting fields, and examines ethical issues in the technological world.
This book is not technical, and should be appropriate for anyone interested in science
or technology.</p>

<p>If you like this book, the authors wrote another called <em>The Mathematical Experience</em>
which is focused more on pure mathematics.</p>

<h3>Computation: Finite &amp; Infinite</h3>

<p>By: <a href="https://en.wikipedia.org/wiki/Marvin_Minsky">Marvin Minsky</a></p>

<p><img src="computation.jpg" alt="computation finite &amp; infinite" /></p>

<p>Marvin Minsky is an incredibly clear and deep writer.
In this work he provides a mathematical framework
for thinking about mechanical machines and develops the
theory of computation.</p>

<p>This book teaches you all you need to know about Turing machines, finite state, and neural networks.
My project: <a href="https://justinmeiners.github.io/neural-nets-sim/">McCulloch &amp; Pitts Neural Net Simulator</a>
is based on this book.</p>

<p>To read this book, you should understand some logic and basic set theory
such as that taught in an introductory proofs course.</p>

<p>Unfortunately, it is out of print and may be difficult to obtain (for a reasonable
amount of money).
I read it from my university&rsquo;s library. If that is not an option, I recommend you <em>find it online</em>.
If anyone knows of a place where I can reasonably purchase this book, let me know.</p>

<h3>Structure and Interpretation of Computer Programs</h3>

<p>By: <a href="https://en.wikipedia.org/wiki/Gerald_Jay_Sussman">Gerald Sussman</a> &amp; <a href="https://en.wikipedia.org/wiki/Hal_Abelson">Hal Abelson</a></p>

<p><img src="sicp.jpg" alt="sicp" /></p>

<p><a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html)">Read Online</a></p>

<p>This classic text is designed to teach programming to MIT students
who have some technical background in another areas of math and science.
It is a hard read, but it assumes no programming knowledge and teaches Scheme (a Lisp dialect) and
its full inter-workings from the ground up.</p>

<p>If you want to be a professional programmer,
this may be the only book you need to study.
What other book teaches you to write a symbolic differentiator,
interpreter, circuit simulator, and compiler?</p>

<p>Most of the material is mixed in the <a href="https://github.com/justinmeiners/excercises/tree/master/sicp">excercises</a>
so don&rsquo;t skip them!</p>

<p>But, this is not just a programming book.
It belongs in this list because it teaches the fundamental concepts of computation.
See the section <a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1.5">data as programs</a> for an example.</p>

<h3>Logical Foundations of Mathematics and Computational Complexity</h3>

<p>By: <a href="http://users.math.cas.cz/~pudlak/">Pavel Pudlak</a></p>

<p><img src="logical_foundations.jpg" alt="logical foundations of math" /></p>

<p>This book is a massive and dense survey of topics including
formal systems, set theory, abstract algebra, computability theory,
analysis of algorithms, and quantum computing.
The first chapter covered almost everything I had learned about
algebra and meta-mathematics in my entire undergraduate degree!</p>

<p>Pudlak does a fantastic job of balancing technical
information with philosophical discussion.
I can&rsquo;t recommend this book enough.</p>

<p>Reading this book definitely requires some mathematical maturity.
The author does his best to explains every concept in the book
but it would be hard for me to read about a &ldquo;group&rdquo; for the first time
and really understand what he means.</p>

<p>If you read through the other books, and have technical knowledge
you should be well prepared.</p> 
 ]]></description>
</item>
<item>
<pubDate>Fri, 22 Feb 2019 00:00:00 -0600</pubDate>
<title>The Skills Poor Programmers Lack</title>
<guid isPermaLink="true">https://justinmeiners.github.io/the-skills-programmers-lack/</guid>
<description><![CDATA[ 
 <h2>The Skills Poor Programmers Lack</h2>

<p><strong>02/22/2019</strong></p>

<p>Updated: <strong>04/27/2020</strong></p>

<p>A friend and I had a discussion about the basic skills that are often lacking in experienced programmers. How can a programmer work for ten or twenty years and never learn to write good code? Too often they need close supervision to ensure they go down the right path, and can never be trusted to take technical leadership on larger tasks. It seems they are just good enough to get by in their job, but they never become <em>effective</em>.</p>

<p>We thought about our experiences and came up with three fundamental skills that we find are most often missing. Note that these are not skills which take a considerable amount of talent or unique insight. Nor are they &ldquo;trends&rdquo; or &ldquo;frameworks&rdquo; to help you get a new job. They are basic fundamentals which are prerequisites to being a successful programmer.</p>

<h2>Understand how the language works</h2>

<p>Programmers cannot write good code unless they understand what they are typing. At the most basic level, this means they need to understand the rules of their programming language well. It is obvious when a programmer doesn&rsquo;t because they solve problems in indirect ways and litter the code with unnecessary statements that they are clueless as to what they actually do. Their mental model of the program does not match with the actual behavior of the code.</p>

<p>You may have seen code which misunderstands how expressions work: (1)</p>

<pre><code>if isDelivered and isNotified:
    isDone = True
else:
    isDone = false;
</code></pre>

<p>Instead of:</p>

<pre><code>isDone = isDelivered and isNotified
</code></pre>

<p>In JavaScript, this is often indicated by <code>new Promise</code> inside a <code>.then()</code>. In C++, it is attaching <code>virtual</code> to every method and destructor and creating every object with <code>new</code>.</p>

<p>Debugging is also extremely difficult if you don&rsquo;t understand the language. You may add a line of code because it fixes a bug for reasons you don&rsquo;t understand. Bugs are mysteries that seem to appear organically, like dust on the shelves. The code has a mind of its own.</p>

<p>Understand the code you write. Know what every line does and why you put it there.</p>

<p>Once you understand the language well, its important to know about implementation; what goes on <em>inside</em> the computer or library? Do you know how the code gets to <a href="http://inst.eecs.berkeley.edu/~cs61c/sp15/">assembly</a>? Do you know how a <a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-21.html#%_sec_3.2">closure captures variables</a>? Do you know how the <a href="https://en.wikipedia.org/wiki/Cheney%27s_algorithm">garbage collector</a> works? Do you know how a <a href="http://opendatastructures.org/ods-python/">map/dictionary</a> works? Do you know how an HTTP request is made?</p>

<p>Modern software and computers are too complex to know everything (2).
The idea is not not to be too clever, but to avoid doing silly things.
Silly mistakes result in sluggish code that is wasteful of system resources, or just does unexpected things.
Removing an item from the front of a C++ <code>vector</code> requires copying the entire vector which is worth thinking about in large cases.
Writing <code>map&lt;string, map&lt;string, ...&gt;&gt;</code> in C++ (a dictionary of dictionaries) creates a a self-balancing tree in which every node is a self-balancing tree, a data structure nobody would intentionally design. (3)</p>

<p>A muddy understanding of how things work is typical of beginners, but it is all too often a problem with experienced programmers if they are not curious and do not take time to learn how things work beyond their immediate jobâs needs.
Learn just a bit more about the stuff you use most works.</p>

<h2>Anticipate problems</h2>

<p>To write reliable code, you must be able to anticipate problems, not just patch individual use cases. I am shocked by the number of times I see code that puts the program in a broken state when a very likely error happens.</p>

<p>I recently reviewed some code that made an HTTP request to notify a server of a state change in which the programmer assumed the HTTP request would always succeed. If it failed, (and we know how often HTTP requests fail), a database record was put into an invalid state. The questions they should have asked when writing this code are: What happens if this fails? Is there another opportunity to send the notification? When is the correct time to record the state change? Careful programmers think through the possible states and transitions of their program.</p>

<p>Using <code>sleep()</code>, cron jobs, or <code>setTimeout</code> is almost always wrong because it typically means you are waiting for a task to finish and donât know how long it will take. What if it takes longer than you expect? What if the scheduler gives resources to another program? Will that break your program? It may take a little bit of effort to rig a proper event, but it is always worth it.</p>

<p>Another common mistake I see is generating a random file or identifier and hoping that collisions will never happen (4). It is reasonable for an unlikely event to cause an error, but it is not ok if that puts your program in an unusable state. For example, if a successful login generates a session token and it collides with another token, you could reject the login and have the user try again. It is a freak accident that slightly inconveniences the user. On the other hand, what if you generate storage files with random names and you have a collision? You just lost someoneâs data! âThis probably wonât happenâ is not a strategy for writing reliable code.</p>

<p>Unit testing canât solve this problem either. It can help you stop and think about some inputs to write a test, but more than likely, the cases that you write tests are the ones you anticipated when you wrote the code! Unit testing cannot transform fragile code into reliable code.</p>

<p>Fragile code is often caused by a lack of experience regarding things that can go wrong, but it can also be the result of a long career of maintaining existing codebases. When working on a large existing system, you typically fix individual bugs and arenât rewarded by your bosses for improving the system as a whole. You learn that programming is a never-ending patch. Increasing the <code>sleep()</code> time may fix the bug today, but never solve the underlying issue.</p>

<h2>Organize and design systems</h2>

<p>Even when armed with the other two skills, it&rsquo;s hard to be effective unless you can organize code into a system that makes sense. I believe OOP and relational database get a lot of flack because programmers tend to be bad at design, not because they are broken paradigms. You simply can&rsquo;t create rigid classes, schemas, and hierarchies without thinking them through. Design itself is too broad a topic to explore in this article (read <a href="https://en.wikipedia.org/wiki/Fred_Brooks">Fred Brooks</a>), so I want to focus on a few specific attributes that well-designed software tends to have.</p>

<p>You may have heard a rule like <a href="http://number-none.com/blow/blog/programming/2014/09/26/carmack-on-inlined-code.html">&ldquo;don&rsquo;t make functions or classes too long&rdquo;</a>. However, the real problem is writing code that mixes unrelated ideas. Poorly designed software lacks conceptual integrity. Its concepts and division of responsibilities are not well defined. It usually looks like a giant Rube Goldberg machine that haphazardly sets state and triggers events.</p>

<p>Accordingly, good software is built from well-defined concepts with clear responsibilities. Mathematicians and <a href="https://en.wikipedia.org/wiki/Categories_(Aristotle)">philosophers</a> spend a lot of time discussing definitions because a good definition allows them to capture and understand some truth about the world. Programmers should think similarly and spend a comparable amount of effort grappling with ideas before writing code.</p>

<p>Good programmers ask questions like:</p>

<ul>
<li>&ldquo;What is this function&rsquo;s purpose?&rdquo;</li>
<li>&ldquo;What does this data structure represent?&rdquo;</li>
<li>&ldquo;Does this function actually represent two separate tasks?&rdquo;</li>
<li>&ldquo;What is the responsibility of this portion of code? What shouldn&rsquo;t it &lsquo;know about&rsquo;?&rdquo;</li>
<li>&ldquo;What is necessary to be in the public interface?&rdquo;</li>
</ul>


<p>Luckily the field is ripe with strategies to help you design code. <a href="https://www.oodesign.com">Design patterns</a> and <a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a> can give you guidelines for designing classes. Functional programming encourages writing pure functions (input -> output and no side effects) and maintaining as little state as possible. <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html">Model view controller</a> aims to separate UI and storage concerns from program logic. On the other hand, React components form conceptual units by combining the HTML, CSS, and JS into a single component. Unix rejects categories and says <a href="https://en.wikipedia.org/wiki/Everything_is_a_file">everything is a file</a>. All of these seemingly contradictory ideas are valid. The important thing is that the concepts make sense and map closely to the problem you are solving.</p>

<p>Software that is well-designed is also software that is easy to change. Of course, it&rsquo;s too much to ask it to satisfy requirements that contradict its original intent. But, it should accommodate changes that are natural evolutions. A common mistake I see is solving a problem for a few cases, instead of N cases. (If you have a variable called <code>button3</code>.) Another is treating everything as a special case using <code>switch</code> statements instead of using polymorphism. (5)</p>

<p>I think the best way to learn about design is to write and study a lot of programs. Programmers who work only on old programs never learn to write new ones. The studying part is key too. Programmers who only work on small temporary projects (like an agency) may get by without ever improving how to design programs. Good design comes gradually with experience, but only if you think about it and try to improve.</p>

<p>There are no tricks or rules that you can follow to guarantee you will write good software. As Alex Stepanov said, &ldquo;think, and then the code will be good.&rdquo;</p>

<ol>
<li><p>There may be some cases where the previous style is preferred.
This example is only an illustration.</p></li>
<li><p>I was shocked when I wrote some multithreaded code and first faced bugs due to
<a href="https://en.wikipedia.org/wiki/Cache_coherence">Cache coherence</a> and <a href="https://preshing.com/20120625/memory-ordering-at-compile-time/">instruction reordering</a>!</p></li>
<li><p>A reader corrected me about the performance of modern <code>map</code> implementations.
Map of map is just as good as alternatives, like map of pair.
I think it is a good illustration of code being suprising,
but perhaps I am doing a bit too much early optimization :)
See his <a href="https://gist.github.com/Dobiasd/fa27e3efb8b08fc81791d7f8e51ac5ca">benchmark</a>.</p></li>
<li><p>There are ways to do this sort of thing correctly using cryptographic hashes.</p></li>
<li><p>Once again, this is just an example. Switching on type may be perfectly appropriate.</p></li>
</ol> 
 ]]></description>
</item>
<item>
<pubDate>Sun, 13 Jan 2019 00:00:00 -0600</pubDate>
<title>McCulloch &amp; Pitts Neural Net Simulator</title>
<guid isPermaLink="true">https://justinmeiners.github.io/neural-nets-sim/</guid>
</item>
</channel>
</rss>
